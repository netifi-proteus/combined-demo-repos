'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deserializeTraceData = deserializeTraceData;
exports.mapToBuffer = mapToBuffer;
exports.bufferToMap = bufferToMap;
exports.trace = trace;
exports.traceAsChild = traceAsChild;
exports.traceSingle = traceSingle;
exports.traceSingleAsChild = traceSingleAsChild;

var _rsocketCore = require('rsocket-core');

var _rsocketFlowable = require('rsocket-flowable');

var _SpanSubscriber = require('./SpanSubscriber');

var _SpanSingle = require('./SpanSingle');

var _opentracing = require('opentracing');

var _proteusJsFrames = require('proteus-js-frames');

function deserializeTraceData(tracer, metadata) {
  if (!tracer) {
    return null;
  }

  var tracingData = (0, _proteusJsFrames.getTracing)(metadata);

  if (_rsocketCore.BufferEncoder.byteLength(tracingData) <= 0) {
    return null;
  }

  return tracer.extract(_opentracing.FORMAT_TEXT_MAP, bufferToMap(tracingData));
}

function mapToBuffer(map) {
  if (!map || Object.keys(map).length <= 0) {
    return (0, _rsocketCore.createBuffer)(0);
  }

  var aggregatedTags = Object.keys(map).reduce(function (aggregate, key) {
    var val = map[key];
    var keyLen = _rsocketCore.UTF8Encoder.byteLength(key);
    var keyBuf = (0, _rsocketCore.createBuffer)(keyLen);
    _rsocketCore.UTF8Encoder.encode(key, keyBuf, 0, keyLen);

    var valLen = _rsocketCore.UTF8Encoder.byteLength(val);
    var valBuf = (0, _rsocketCore.createBuffer)(valLen);
    _rsocketCore.UTF8Encoder.encode(val, valBuf, 0, valLen);

    var newEntries = aggregate.entries;
    newEntries.push({ keyLen: keyLen, keyBuf: keyBuf, valLen: valLen, valBuf: valBuf });

    return {
      //4 for the sizes plus the actual key and actual value
      totalSize: aggregate.totalSize + 4 + keyLen + valLen,
      entries: newEntries
    };
  }, { totalSize: 0, entries: [] });

  var offset = 0;
  var resultBuf = (0, _rsocketCore.createBuffer)(aggregatedTags.totalSize);
  aggregatedTags.entries.forEach(function (entry) {
    resultBuf.writeUInt16BE(entry.keyLen, offset);
    offset += 2; //2 bytes for key length

    _rsocketCore.BufferEncoder.encode(entry.keyBuf, resultBuf, offset, offset + entry.keyLen);
    offset += entry.keyLen;

    resultBuf.writeUInt16BE(entry.valLen, offset);
    offset += 2;

    _rsocketCore.BufferEncoder.encode(entry.valBuf, resultBuf, offset, offset + entry.valLen);
    offset += entry.valLen;
  });

  return resultBuf;
}

function bufferToMap(buffer) {
  var result = {};

  var offset = 0;
  while (offset < buffer.length) {
    var keyLen = buffer.readUInt16BE(offset);
    offset += 2;

    var key = _rsocketCore.UTF8Encoder.decode(buffer, offset, offset + keyLen);
    offset += keyLen;

    var valLen = buffer.readUInt16BE(offset);
    offset += 2;

    var value = _rsocketCore.UTF8Encoder.decode(buffer, offset, offset + valLen);
    offset += valLen;

    result[key] = value;
  }

  return result;
}

function trace(tracer, name) {
  for (var _len = arguments.length, tags = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    tags[_key - 2] = arguments[_key];
  }

  if (tracer && name) {
    return function (metadata) {
      return function (flowable) {
        return flowable.lift(function (subscriber) {
          return new _SpanSubscriber.SpanSubscriber(subscriber, tracer, name, null, metadata, tags);
        });
      };
    };
  } else {
    return function (map) {
      return function (publisher) {
        return publisher;
      };
    };
  }
}

function traceAsChild(tracer, name) {
  for (var _len2 = arguments.length, tags = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    tags[_key2 - 2] = arguments[_key2];
  }

  if (tracer && name) {
    return function (context) {
      return function (flowable) {
        return flowable.lift(function (subscriber) {
          return new _SpanSubscriber.SpanSubscriber(subscriber, tracer, name, context, null, tags);
        });
      };
    };
  } else {
    return function (context) {
      return function (publisher) {
        return publisher;
      };
    };
  }
}

function traceSingle(tracer, name) {
  for (var _len3 = arguments.length, tags = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
    tags[_key3 - 2] = arguments[_key3];
  }

  if (tracer && name) {
    return function (metadata) {
      return function (single) {
        return (0, _SpanSingle.createSpanSingle)(single, tracer, name, null, metadata, tags);
      };
    };
  } else {
    return function (map) {
      return function (single) {
        return single;
      };
    };
  }
}

function traceSingleAsChild(tracer, name) {
  for (var _len4 = arguments.length, tags = Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
    tags[_key4 - 2] = arguments[_key4];
  }

  if (tracer && name) {
    return function (context) {
      return function (single) {
        return (0, _SpanSingle.createSpanSingle)(single, tracer, name, context, null, tags);
      };
    };
  } else {
    return function (context) {
      return function (single) {
        return single;
      };
    };
  }
}