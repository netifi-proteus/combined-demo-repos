'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ZipkinTracingService = undefined;

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _zipkin_pb = require('../zipkin/proto3/zipkin_pb');

var _tracing_pb = require('../proteus/tracing_pb');

var _rsocketFlowable = require('rsocket-flowable');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ZipkinTracingService = exports.ZipkinTracingService = function () {
  function ZipkinTracingService(host, port, zipkinUrl) {
    _classCallCheck(this, ZipkinTracingService);

    this._host = host;
    this._path = zipkinUrl;
    this._port = port;
  }

  ZipkinTracingService.prototype.sendSpan = function sendSpan(span, metadata) {
    var _this = this;

    var result = new _rsocketFlowable.Single(function (sub) {
      sub.onSubscribe();
      var post_body = '[' + convertSpan(span) + ']';

      var post_options = {
        host: _this._host,
        port: _this._port,
        path: _this._path,
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        }
      };

      // Set up the request
      console.log('Posting span...');
      var post_req = _http2.default.request(post_options, function (res) {
        res.setEncoding('utf8');
        res.on('data', function (chunk) {
          console.log('Response chunk: ' + chunk);
        });
        res.on('end', function () {
          console.log('Done!');
          sub.onComplete(new _tracing_pb.Ack());
        });
      });
      console.log('Logging:' + post_body);
      post_req.write(post_body);
      post_req.end();
    });
    return result;
  };

  return ZipkinTracingService;
}();

var kind = {
  0: 'SPAN_KIND_UNSPECIFIED',
  1: 'CLIENT',
  2: 'SERVER',
  3: 'PRODUCER',
  4: 'CONSUMER'
};
function convertSpan(span) {
  var obj = span.toObject();
  //Map KIND from number back to string for Go library
  obj.kind = kind[obj.kind];
  //Fix id lengths
  obj.traceId = (obj.traceId || '').padStart(32, '0');
  obj.id = (obj.id || '').padStart(16, '0');
  obj.parentId = (obj.parentId || '').padStart(16, '0');
  //Format requires that parentId is absent for "root" trace
  if (obj.id === obj.parentId) {
    delete obj.parentId;
  }
  //Rename annotations to expected name
  obj.annotations = obj.annotationsList;
  delete obj.annotationsList;
  //Restructure tags to a map and rename per expectation
  obj.tags = obj.tagsMap.reduce(function (agg, kvp) {
    agg[kvp[0]] = kvp[1];
    return agg;
  }, {});
  delete obj.tagsMap;

  if (!obj.debug) {
    delete obj.debug;
  }

  if (!obj.shared) {
    delete obj.shared;
  }

  return JSON.stringify(obj);
}