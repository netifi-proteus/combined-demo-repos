'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpanSubscriber = undefined;

var _rsocketTypes = require('rsocket-types');

var _opentracing = require('opentracing');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SpanSubscriber = exports.SpanSubscriber = function () {
  function SpanSubscriber(subscriber, tracer, name, context, metadata) {
    _classCallCheck(this, SpanSubscriber);

    this._tracer = tracer;
    this._subscriber = subscriber;
    this._nextCount = 0;
    this._requestCount = 0;

    var options = {};

    if (context) {
      options.childOf = context;
    }

    for (var _len = arguments.length, tags = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
      tags[_key - 5] = arguments[_key];
    }

    if (tags) {
      var finalTags = {};
      tags.forEach(function (tagArr) {
        tagArr.forEach(function (tag) {
          Object.keys(tag).forEach(function (key) {
            finalTags[key] = tag[key];
          });
        });
      });
      options.tags = finalTags;
    }

    //Not currently supported
    // if (references) {
    //   options.references = references;
    // }
    //

    options.startTime = Date.now() * 1000;

    this._span = tracer.startSpan(name, options);
    this._rootSpan = this._rootSpan || this._span;

    tracer.inject(this._span.context(), _opentracing.FORMAT_TEXT_MAP, metadata === undefined || metadata === null ? {} : metadata);
  }

  SpanSubscriber.prototype.cleanup = function cleanup() {
    this._span.finish();
  };

  SpanSubscriber.prototype.onSubscribe = function onSubscribe(subscription) {
    this._subscription = subscription;
    this._span.log('onSubscribe', timeInMicros());
    this._subscriber.onSubscribe(this);
  };

  SpanSubscriber.prototype.request = function request(n) {
    this._span.log('request#' + ++this._requestCount + ': ' + n + ' items', timeInMicros());
    this._subscription && this._subscription.request(n);
  };

  SpanSubscriber.prototype.cancel = function cancel() {
    try {
      this._span.log('cancel', timeInMicros());
      this._subscription && this._subscription.cancel();
    } finally {
      this.cleanup();
    }
  };

  SpanSubscriber.prototype.onNext = function onNext(value) {
    this._span.log('onNext#' + ++this._nextCount, timeInMicros());
    this._subscriber.onNext(value);
  };

  SpanSubscriber.prototype.onError = function onError(error) {
    try {
      this._span.log('onError', timeInMicros());
      this._subscriber.onError(error);
    } finally {
      this.cleanup();
    }
  };

  SpanSubscriber.prototype.onComplete = function onComplete() {
    try {
      this._span.log('onComplete', timeInMicros());
      this._subscriber.onComplete();
    } finally {
      this.cleanup();
    }
  };

  return SpanSubscriber;
}();

function timeInMicros() {
  return Date.now() * 1000 /*microseconds*/;
}