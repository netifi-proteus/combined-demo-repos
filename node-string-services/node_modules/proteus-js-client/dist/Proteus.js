'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _rsocketTypes = require('rsocket-types');

var _rsocketFlowable = require('rsocket-flowable');

var _rsocketCore = require('rsocket-core');

var _proteusJsCore = require('proteus-js-core');

var _invariant = require('fbjs/lib/invariant');

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Copyright (c) 2017-present, Netifi Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * 
 */

'use-strict';

var RSocketWebSocketClient = require('rsocket-websocket-client').default;

var Proteus = function () {
  function Proteus(proteusClient, requestHandler) {
    var _this = this;

    _classCallCheck(this, Proteus);

    this._client = proteusClient;
    this._group = proteusClient.group();
    this._destination = proteusClient.destination();
    this._connect = function () {
      if (_this._connection) {
        return _rsocketFlowable.Single.of(_this._connection);
      } else if (_this._connecting) {
        return new _rsocketFlowable.Single(function (subscriber) {
          _this._connecting.subscribe(subscriber);
        });
      } else {
        /*** This is a useful Publisher implementation that wraps could feasibly wrap the Single type ***/
        /*** Might be useful to clean up and contribute back or put in a utility or something ***/
        _this._connecting = function () {
          var _subscribers = [];
          var _connection = void 0;
          var _completed = false;
          return {
            onComplete: function onComplete(connection) {
              //Memoize for future subscribers
              _completed = true;
              _connection = connection;

              _subscribers.map(function (subscriber) {
                if (subscriber.onComplete) {
                  subscriber.onComplete(connection);
                }
              });
            },

            onError: function onError(error) {
              _subscribers.map(function (subscriber) {
                if (subscriber.onError) {
                  subscriber.onError(error);
                }
              });
            },

            onSubscribe: function onSubscribe(cancel) {
              _subscribers.map(function (subscriber) {
                if (subscriber.onSubscribe) {
                  subscriber.onSubscribe(cancel);
                }
              });
            },

            subscribe: function subscribe(subscriber) {
              if (_completed) {
                subscriber.onSubscribe();
                subscriber.onComplete(_connection);
              } else {
                _subscribers.push(subscriber);
                if (subscriber.onSubscribe) {
                  subscriber.onSubscribe(function () {
                    var idx = _subscribers.indexOf(subscriber);
                    if (idx > -1) {
                      _subscribers.splice(idx, 1);
                    }
                  });
                }
              }
            }
          };
        }();

        proteusClient.connect().subscribe(_this._connecting);
        _this._connecting.subscribe({
          onComplete: function onComplete(connection) {
            _this._connection = connection;
          }
        });
        return _this._connecting;
      }
    };
    this._requestHandler = requestHandler;
  }

  Proteus.prototype.myGroup = function myGroup() {
    return this._group;
  };

  Proteus.prototype.myDestination = function myDestination() {
    return this._destination;
  };

  Proteus.prototype.broadcast = function broadcast(group) {
    return _proteusJsCore.DeferredConnectingRSocket.broadcast(this._group, this._destination, group, this._connect);
  };

  Proteus.prototype.group = function (_group) {
    function group(_x) {
      return _group.apply(this, arguments);
    }

    group.toString = function () {
      return _group.toString();
    };

    return group;
  }(function (group) {
    return _proteusJsCore.DeferredConnectingRSocket.group(this._group, this._destination, group, this._connect);
  });

  Proteus.prototype.destination = function (_destination) {
    function destination(_x2, _x3) {
      return _destination.apply(this, arguments);
    }

    destination.toString = function () {
      return _destination.toString();
    };

    return destination;
  }(function (destination, group) {
    return _proteusJsCore.DeferredConnectingRSocket.destination(this._group, this._destination, group, destination, this._connect);
  });

  Proteus.prototype.addService = function addService(service, handler) {
    this._requestHandler.addService(service, handler);
  };

  Proteus.prototype.close = function close() {
    this._client.close();
  };

  Proteus.create = function create(config) {
    (0, _invariant2.default)(config && config.setup && config.setup.accessKey && config.setup.accessToken && config.transport, 'Proteus: Falsey config is invalid. At minimum transport config, group, access key, and access token are required.');

    (0, _invariant2.default)(config.transport.connection || config.transport.url, 'Proteus: Transport config must supply a connection or a URL');

    //default to GUID-y destination ID
    var destination = config.setup.destination !== undefined ? config.setup.destination : uuidv4();
    var keepAlive = config.setup.keepAlive !== undefined ? config.setup.keepAlive : 60000 /* 60s in ms */;
    var lifetime = config.setup.lifetime !== undefined ? config.setup.lifetime : 360000 /* 360s in ms */;
    var accessKey = config.setup.accessKey;
    var accessToken = Buffer.from(config.setup.accessToken, 'base64');

    var transport = config.transport.connection !== undefined ? config.transport.connection : new RSocketWebSocketClient({
      url: config.transport.url ? config.transport.url : 'ws://'
    }, _rsocketCore.BufferEncoders);

    var requestHandler = new _proteusJsCore.RequestHandlingRSocket();
    var responder = new _proteusJsCore.UnwrappingRSocket(requestHandler);

    var finalConfig = {
      setup: {
        group: config.setup.group,
        destination: destination,
        keepAlive: keepAlive,
        lifetime: lifetime,
        accessKey: accessKey,
        accessToken: accessToken
      },
      transport: transport,
      responder: responder
    };

    if (config.responder !== undefined) {
      finalConfig.responder = config.responder;
    }

    if (config.serializers !== undefined) {
      finalConfig.serializers = config.serializers;
    }

    var client = new _proteusJsCore.ProteusClient(finalConfig);

    return new Proteus(client, requestHandler);
  };

  return Proteus;
}();

//Helper function to generate GUID-ish IDs, should a user not provide one


exports.default = Proteus;
function uuidv4() {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0,
        v = c == 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}