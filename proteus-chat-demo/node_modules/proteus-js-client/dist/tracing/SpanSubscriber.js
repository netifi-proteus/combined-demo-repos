'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SpanSubscriber = undefined;

var _rsocketTypes = require('rsocket-types');

var _opentracing = require('opentracing');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SpanSubscriber = exports.SpanSubscriber = function () {
  function SpanSubscriber(subscriber, tracer, name, context, tags, references, startTime) {
    _classCallCheck(this, SpanSubscriber);

    this._tracer = tracer;
    this._subscriber = subscriber;

    var options = {};

    if (context) {
      options.childOf = context;
    } else if (this._rootSpan) {
      options.childOf = context;
    }

    if (tags) {
      options.tags = tags;
    }

    if (references) {
      options.references = references;
    }

    if (startTime) {
      options.startTime = startTime;
    }

    this._span = tracer.startSpan(name, options);
    this._rootSpan = this._rootSpan || this._span;

    var adapter = new _opentracing.BinaryCarrier();
    tracer.inject(this._span.context(), _opentracing.FORMAT_BINARY, adapter);
  }

  SpanSubscriber.prototype.cleanup = function cleanup() {
    this._span.finish();
  };

  SpanSubscriber.prototype.onSubscribe = function onSubscribe(subscription) {
    this._subscription = subscription;
    this._span.log('onSubscribe', timeInMicros());
    this._subscriber.onSubscribe(this);
  };

  SpanSubscriber.prototype.request = function request(n) {
    this._span.log('request', timeInMicros());
    this._subscription && this._subscription.request(n);
  };

  SpanSubscriber.prototype.cancel = function cancel() {
    try {
      this._span.log('cancel', timeInMicros());
      this._subscription && this._subscription.cancel();
    } finally {
      this.cleanup();
    }
  };

  SpanSubscriber.prototype.onNext = function onNext(value) {
    this._span.log('onNext', timeInMicros());
    this._subscriber.onNext(value);
  };

  SpanSubscriber.prototype.onError = function onError(error) {
    try {
      this._span.log('onError', timeInMicros());
      this._subscriber.onError(error);
    } finally {
      this.cleanup();
    }
  };

  SpanSubscriber.prototype.onComplete = function onComplete() {
    try {
      this._span.log('onComplete', timeInMicros());
      this._subscriber.onComplete();
    } finally {
      this.cleanup();
    }
  };

  return SpanSubscriber;
}();

function timeInMicros() {
  return Date.now() * 1000 /*microseconds*/;
}