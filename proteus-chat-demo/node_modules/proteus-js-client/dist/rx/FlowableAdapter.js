'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = toObservable;

var _Rx = require('rxjs/Rx');

var _rsocketTypes = require('rsocket-types');

var _rsocketFlowable = require('rsocket-flowable');

var _rxjs = require('rxjs');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           * Copyright (c) 2017-present, Netifi Inc.
                                                                                                                                                           *
                                                                                                                                                           * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                           * you may not use this file except in compliance with the License.
                                                                                                                                                           * You may obtain a copy of the License at
                                                                                                                                                           *
                                                                                                                                                           *       http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                           *
                                                                                                                                                           * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                           * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                           * See the License for the specific language governing permissions and
                                                                                                                                                           * limitations under the License.
                                                                                                                                                           */

function toObservable(rsocketType, batchSize) {
  if (rsocketType instanceof _rsocketFlowable.Flowable) {
    return (0, _rxjs.from)(new ObservableFlowable(rsocketType, batchSize));
  } else if (rsocketType instanceof _rsocketFlowable.Single) {
    return (0, _rxjs.from)(new ObservableSingle(rsocketType));
  } else {
    console.log('Unrecognized type: ' + rsocketType);
    return (0, _rxjs.from)(rsocketType);
  }
}

var ObservableFlowable = function () {
  function ObservableFlowable(delegate) {
    var _this = this;

    var batchSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_SAFE_INTEGER;

    _classCallCheck(this, ObservableFlowable);

    //Symbol logic cloned from observable.ts in rxjs
    var observableSymbol = typeof Symbol === 'function' && Symbol.observable ? Symbol.observable : '@@observable';
    this[observableSymbol] = function () {
      return _this;
    };
    this._source = delegate;
    this._batchSize = batchSize;
  }

  ObservableFlowable.prototype.subscribe = function subscribe(subscriber) {
    var _this2 = this;

    var unsubscribe = new UnsubscribableSubscription();
    this._source.subscribe(new PartialSubscriberAdapter(function (value) {
      if (!unsubscribe.isCanceled()) {
        if (subscriber && subscriber.next) {
          try {
            subscriber.next(value);
            //Only if someone specified a batch size
            if (_this2._batchSize < Number.MAX_SAFE_INTEGER) {
              _this2._buffered--;
              if (_this2._buffered <= 0) {
                _this2._buffered = _this2._batchSize;
                _this2._subscription.request(_this2._batchSize);
              }
            }
          } catch (error) {
            if (subscriber && subscriber.error) {
              subscriber.error(error);
              unsubscribe.unsubscribe();
            }
          }
        }
      }
    }, function (error) {
      if (subscriber && subscriber.error) {
        subscriber.error(error);
      }
    }, function () {
      if (subscriber && subscriber.complete) {
        subscriber.complete();
      }
    }, function (subscription) {
      if (subscription) {
        _this2._subscription = subscription;
        unsubscribe.setCancelHandle(_this2._subscription.cancel);
        _this2._buffered = _this2._batchSize;
        _this2._subscription.request(_this2._batchSize);
      }
    }));

    return unsubscribe;
  };

  return ObservableFlowable;
}();

var ObservableSingle = function () {
  function ObservableSingle(delegate) {
    var _this3 = this;

    _classCallCheck(this, ObservableSingle);

    //Symbol logic cloned from observable.ts in rxjs
    var observableSymbol = typeof Symbol === 'function' && Symbol.observable ? Symbol.observable : '@@observable';
    this[observableSymbol] = function () {
      return _this3;
    };
    this._source = delegate;
    this._completed = false;
  }

  ObservableSingle.prototype.subscribe = function subscribe(subscriber) {
    var _this4 = this;

    var unsubscribe = new UnsubscribableSubscription();
    this._source.subscribe(new PartialFutureSubscriberAdapter(function (value) {
      if (!_this4._completed) {
        try {
          if (subscriber && subscriber.next) {
            subscriber.next(value);
            _this4._completed = true;
            if (subscriber && subscriber.complete) {
              subscriber.complete();
            }
          }
        } catch (error) {
          if (subscriber && subscriber.error) {
            subscriber.error(error);
          }
        }
      }
    }, function (error) {
      subscriber && subscriber.error && subscriber.error(error);
    }, function (cancel) {
      if (cancel) {
        unsubscribe.setCancelHandle(cancel);
      }
    }));

    return unsubscribe;
  };

  return ObservableSingle;
}();

/*** Helper classes ***/

var UnsubscribableSubscription = function () {
  function UnsubscribableSubscription() {
    _classCallCheck(this, UnsubscribableSubscription);

    this._canceled = false;
  }

  UnsubscribableSubscription.prototype.isCanceled = function isCanceled() {
    return this._canceled;
  };

  UnsubscribableSubscription.prototype.unsubscribe = function unsubscribe() {
    this._canceled = true;
    if (this._cancel) {
      this._cancel();
    }
  };

  UnsubscribableSubscription.prototype.setCancelHandle = function setCancelHandle(cancel) {
    this._cancel = cancel;
    if (this._canceled) {
      this._cancel();
    }
  };

  return UnsubscribableSubscription;
}();

var PartialFutureSubscriberAdapter = function PartialFutureSubscriberAdapter(onComplete, onError, onSubscribe) {
  _classCallCheck(this, PartialFutureSubscriberAdapter);

  this.onComplete = onComplete;
  this.onError = onError;
  this.onSubscribe = onSubscribe;
};

var PartialSubscriberAdapter = function PartialSubscriberAdapter(onNext, onError, onComplete, onSubscribe) {
  _classCallCheck(this, PartialSubscriberAdapter);

  this.onNext = onNext;
  this.onError = onError;
  this.onComplete = onComplete;
  this.onSubscribe = onSubscribe;
};