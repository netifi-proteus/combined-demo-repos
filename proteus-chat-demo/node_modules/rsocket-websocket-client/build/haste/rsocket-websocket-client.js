'use strict';

var invariant = require('invariant');
var rsocketFlowable = require('rsocket-flowable');
var rsocketCore = require('rsocket-core');
var rsocketTypes = require('rsocket-types');

/**
                                              * Copyright (c) 2017-present, Facebook, Inc.
                                              * All rights reserved.
                                              *
                                              * This source code is licensed under the BSD-style license found in the
                                              * LICENSE file in the root directory of this source tree. An additional grant
                                              * of patent rights can be found in the PATENTS file in the same directory.
                                              *
                                              * 
                                              */

/**
                                                                                                     * A WebSocket transport client for use in browser environments.
                                                                                                     */
class RSocketWebSocketClient$1 {
  constructor(options, encoders) {
    this._handleClosed = () => {
      this._close(
        new Error('RSocketWebSocketClient: Socket closed unexpectedly.')
      );
    };
    this._handleError = error => {
      this._close(error);
    };
    this._handleOpened = () => {
      this._setConnectionStatus(rsocketTypes.CONNECTION_STATUS.CONNECTED);
    };
    this._handleMessage = message => {
      try {
        const frame = this._readFrame(message);
        this._receivers.forEach(subscriber => subscriber.onNext(frame));
      } catch (error) {
        this._handleError(error);
      }
    };
    this._encoders = encoders;
    this._options = options;
    this._receivers = new Set();
    this._senders = new Set();
    this._socket = null;
    this._status = rsocketTypes.CONNECTION_STATUS.NOT_CONNECTED;
    this._statusSubscribers = new Set();
  }
  close() {
    this._close();
  }
  connect() {
    invariant(
      this._status.kind === 'NOT_CONNECTED',
      'RSocketWebSocketClient: Cannot connect(), a connection is already ' +
        'established.'
    );
    this._setConnectionStatus(rsocketTypes.CONNECTION_STATUS.CONNECTING);
    const socket = (this._socket = new WebSocket(this._options.url));
    socket.binaryType = 'arraybuffer';
    socket.addEventListener('close', this._handleClosed);
    socket.addEventListener('error', this._handleClosed);
    socket.addEventListener('open', this._handleOpened);
    socket.addEventListener('message', this._handleMessage);
  }
  connectionStatus() {
    return new rsocketFlowable.Flowable(subscriber => {
      subscriber.onSubscribe({
        cancel: () => {
          this._statusSubscribers.delete(subscriber);
        },
        request: () => {
          this._statusSubscribers.add(subscriber);
          subscriber.onNext(this._status);
        },
      });
    });
  }
  receive() {
    return new rsocketFlowable.Flowable(subject => {
      subject.onSubscribe({
        cancel: () => {
          this._receivers.delete(subject);
        },
        request: () => {
          this._receivers.add(subject);
        },
      });
    });
  }
  sendOne(frame) {
    this._writeFrame(frame);
  }
  send(frames) {
    let subscription;
    frames.subscribe({
      onComplete: () => {
        subscription && this._senders.delete(subscription);
      },
      onError: error => {
        subscription && this._senders.delete(subscription);
        this._handleError(error);
      },
      onNext: frame => this._writeFrame(frame),
      onSubscribe: _subscription => {
        subscription = _subscription;
        this._senders.add(subscription);
        subscription.request(Number.MAX_SAFE_INTEGER);
      },
    });
  }
  _close(error) {
    if (this._status.kind === 'CLOSED' || this._status.kind === 'ERROR') {
      // already closed
      return;
    }
    const status = error
      ? {error, kind: 'ERROR'}
      : rsocketTypes.CONNECTION_STATUS.CLOSED;
    this._setConnectionStatus(status);
    this._receivers.forEach(subscriber => {
      if (error) {
        subscriber.onError(error);
      } else {
        subscriber.onComplete();
      }
    });
    this._receivers.clear();
    this._senders.forEach(subscription => subscription.cancel());
    this._senders.clear();
    const socket = this._socket;
    if (socket) {
      socket.removeEventListener('close', this._handleClosed);
      socket.removeEventListener('error', this._handleClosed);
      socket.removeEventListener('open', this._handleOpened);
      socket.removeEventListener('message', this._handleMessage);
      socket.close();
      this._socket = null;
    }
  }
  _setConnectionStatus(status) {
    this._status = status;
    this._statusSubscribers.forEach(subscriber => subscriber.onNext(status));
  }
  _readFrame(message) {
    const buffer = rsocketCore.toBuffer(message.data);
    const frame = this._options.lengthPrefixedFrames
      ? rsocketCore.deserializeFrameWithLength(buffer, this._encoders)
      : rsocketCore.deserializeFrame(buffer, this._encoders);
    return frame;
  }

  _writeFrame(frame) {
    try {
      const buffer = this._options.lengthPrefixedFrames
        ? rsocketCore.serializeFrameWithLength(frame, this._encoders)
        : rsocketCore.serializeFrame(frame, this._encoders);
      invariant(
        this._socket,
        'RSocketWebSocketClient: Cannot send frame, not connected.'
      );

      this._socket.send(buffer);
    } catch (error) {
      this._handleError(error);
    }
  }
}

/**
      * Copyright (c) 2017-present, Facebook, Inc.
      * All rights reserved.
      *
      * This source code is licensed under the BSD-style license found in the
      * LICENSE file in the root directory of this source tree. An additional grant
      * of patent rights can be found in the PATENTS file in the same directory.
      *
      * 
      */

module.exports = RSocketWebSocketClient$1;
