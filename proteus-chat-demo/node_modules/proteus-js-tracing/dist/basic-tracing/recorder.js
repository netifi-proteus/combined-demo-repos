'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ZipkinRecorder = exports.DefaultRecorder = undefined;

var _zipkin_pb = require('../zipkin/proto3/zipkin_pb');

var _long = require('long');

var _long2 = _interopRequireDefault(_long);

var _tracing_proteus_pb = require('../proteus/tracing_proteus_pb');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DefaultRecorder = exports.DefaultRecorder = function () {
  function DefaultRecorder() {
    _classCallCheck(this, DefaultRecorder);
  }

  /**
   * @param  {BasicSpan}
   *         Span to record, BasicSpan has following fields
   *         - `operationName` {String}
   *         - `startTime` {Number}
   *         - `duration` {Number}
   *         - `tags` {Object} Optional
   *         - `logs` {Array} Optional
   *         - `traceId` {Long} Fixed64 unique id represent by
   *             [long.js](https://github.com/dcodeIO/long.js) instance.
   *         - `spanId` {Long} Fixed64 unique id.
   *         - `parentId` {String}
   *         - `sampled` {Boolean}
   *         - `baggage` {Object} Default to empty object if no baggage in span.
   */
  DefaultRecorder.prototype.record = function record(span) {
    // eslint-disable-line
  };

  return DefaultRecorder;
}();

var ZipkinRecorder = exports.ZipkinRecorder = function (_DefaultRecorder) {
  _inherits(ZipkinRecorder, _DefaultRecorder);

  function ZipkinRecorder(proteusGateway, localService, remoteService, shared) {
    _classCallCheck(this, ZipkinRecorder);

    var _this = _possibleConstructorReturn(this, _DefaultRecorder.call(this));

    _this._group = proteusGateway.myGroup();
    _this._destination = proteusGateway.myDestination();
    _this._localService = localService;
    _this._remoteService = remoteService;
    _this._shared = shared;
    if (proteusGateway) {
      _this._client = new _tracing_proteus_pb.ProteusTracingServiceClient(proteusGateway.group('com.netifi.proteus.tracing'));
    }
    return _this;
  }

  ZipkinRecorder.prototype.record = function record(span) {
    if (this._client) {
      try {
        var loggableSpan = mapSpan(span, this._localService, this._remoteService, this._group, this._destination, this._service, this._shared);
        this._client.sendSpan(loggableSpan, Buffer.alloc(0)).subscribe({
          onComplete: function onComplete(ack) {
            //Great, done
          },
          onError: function onError(err) {
            console.log('Failed to log span:' + span.spanId.toString() + ' ' + err);
          },
          onSubscribe: function onSubscribe(cancel) {
            //No intention of canceling
          }
        });
      } catch (error) {
        console.log('Error occurred while attempting to send trace: ' + error);
      }
    }
  };

  return ZipkinRecorder;
}(DefaultRecorder);

function mapSpan(span, localService, remoteService, group, destination, service, shared) {
  var result = new _zipkin_pb.Span();
  result.setName(span.operationName.toString());
  result.setTraceId(span.traceId.toString());
  result.setId(span.spanId.toString());
  result.setDuration(_long2.default.fromNumber(span.duration));
  result.setTimestamp(_long2.default.fromNumber(span.startTime));
  if (span.spanId.toString() !== span.parentId.toString()) {
    result.setParentId(span.parentId.toString());
  }
  //kind
  if (span.tags['proteus.type']) {
    var kindString = span.tags['proteus.type'].toString().toUpperCase();
    var kind = _zipkin_pb.Span.Kind[kindString] || _zipkin_pb.Span.Kind.SPAN_KIND_UNSPECIFIED;
    result.setKind(kind);
  }
  if (span.tags) {
    var map = result.getTagsMap();
    Object.keys(span.tags).forEach(function (key) {
      map.set(key, span.tags[key]);
    });
    if (group) {
      map.set('group', group);
    }
    if (destination) {
      map.set('destination', destination);
    }
  }
  if (span.logs) {
    var annotations = [];
    span.logs.forEach(function (log) {
      var annotation = new _zipkin_pb.Annotation();
      annotation.setTimestamp(log.timestamp);
      annotation.setValue(log.event);
      annotations.push(annotation);
    });
    result.setAnnotationsList(annotations);
  }
  if (localService) {
    result.setLocalEndpoint(constructEndpoint(localService));
  }
  if (remoteService) {
    result.setRemoteEndpoint(constructEndpoint(remoteService));
  }
  result.setShared(!!shared);

  return result;
}

function constructEndpoint(service) {
  var endpoint = new _zipkin_pb.Endpoint();
  endpoint.setServiceName(service);
  //TODO: Figure this out for real
  endpoint.setIpv4('127.0.0.1');
  return endpoint;
}