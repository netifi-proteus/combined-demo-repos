'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TextMapPropagator = undefined;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _long = require('long');

var _long2 = _interopRequireDefault(_long);

var _span = require('./span');

var _span2 = _interopRequireDefault(_span);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PREFIX_TRACER_STATE = 'ot-tracer-';
var PREFIX_BAGGAGE = 'ot-baggage-';
var FIELD_NAME_TRACE_ID = PREFIX_TRACER_STATE + 'traceid';
var FIELD_NAME_SPAN_ID = PREFIX_TRACER_STATE + 'spanid';
var FIELD_NAME_SAMPLED = PREFIX_TRACER_STATE + 'sampled';
var FIELD_COUNT = 3;

var TextMapPropagator = exports.TextMapPropagator = function () {
  function TextMapPropagator(tracer) {
    _classCallCheck(this, TextMapPropagator);

    this._tracer = tracer;
  }

  TextMapPropagator.prototype.inject = function inject(span, carrier) {
    carrier[FIELD_NAME_TRACE_ID] = span.traceId.toString();
    carrier[FIELD_NAME_SPAN_ID] = span.spanId.toString();
    carrier[FIELD_NAME_SAMPLED] = String(span.sampled);
    for (var key in span.baggage) {
      carrier[PREFIX_BAGGAGE + key] = span.baggage[key];
    }
  };

  TextMapPropagator.prototype.extract = function extract(carrier) {
    return this.join(null, carrier);
  };

  TextMapPropagator.prototype.join = function join(operationName, carrier) {
    var parent = {
      baggage: {}
    };
    var count = 0;
    for (var field in carrier) {
      if (field === FIELD_NAME_TRACE_ID) {
        //parent.traceId = Long.fromString(carrier[field], true);
        parent.traceId = carrier[field];
        count += 1;
      } else if (field === FIELD_NAME_SPAN_ID) {
        //parent.spanId = Long.fromString(carrier[field], true);
        parent.spanId = carrier[field];
        count += 1;
      } else if (field === FIELD_NAME_SAMPLED) {
        if (carrier[field] !== 'true' && carrier[field] !== 'false') {
          throw new Error('Trace corrupted, sampled should be type ' + ('Boolean, got ' + carrier[field]));
        }
        parent.sampled = Boolean(carrier[field]);
        count += 1;
      } else if (field.indexOf(PREFIX_BAGGAGE) === 0) {
        parent.baggage[field.slice(PREFIX_BAGGAGE.length)] = carrier[field];
      }
    }
    if (count !== FIELD_COUNT) {
      throw new Error('Trace corrupted, ' + 'require traceId, spanId and sampled');
    }
    return new _span2.default(this._tracer, {
      operationName: operationName,
      spanId: parent.spanId,
      parent: parent
    });
  };

  return TextMapPropagator;
}();