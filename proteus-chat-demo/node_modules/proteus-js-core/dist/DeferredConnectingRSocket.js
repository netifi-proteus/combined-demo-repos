'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _rsocketFlowable = require('rsocket-flowable');

var _proteusJsFrames = require('proteus-js-frames');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /**
                                                                                                                                                           * Copyright (c) 2017-present, Netifi Inc.
                                                                                                                                                           *
                                                                                                                                                           * Licensed under the Apache License, Version 2.0 (the "License");
                                                                                                                                                           * you may not use this file except in compliance with the License.
                                                                                                                                                           * You may obtain a copy of the License at
                                                                                                                                                           *
                                                                                                                                                           *       http://www.apache.org/licenses/LICENSE-2.0
                                                                                                                                                           *
                                                                                                                                                           * Unless required by applicable law or agreed to in writing, software
                                                                                                                                                           * distributed under the License is distributed on an "AS IS" BASIS,
                                                                                                                                                           * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                                                                                                                                                           * See the License for the specific language governing permissions and
                                                                                                                                                           * limitations under the License.
                                                                                                                                                           *
                                                                                                                                                           * 
                                                                                                                                                           */

var DeferredConnectingRSocket = function () {
  function DeferredConnectingRSocket(transformer, connect) {
    _classCallCheck(this, DeferredConnectingRSocket);

    this._transformer = transformer;
    this._connect = connect;
  }
  // _error: Error;
  // _connected: boolean;
  // _connecting: Single<ReactiveSocket<Buffer, Buffer>>;
  // _connection: ReactiveSocket<Buffer, Buffer>;


  DeferredConnectingRSocket.broadcast = function broadcast(fromGroup, fromDestination, toGroup, connect) {
    return new DeferredConnectingRSocket(function (payload) {
      var metadata = (0, _proteusJsFrames.encodeFrame)({
        type: _proteusJsFrames.FrameTypes.BROADCAST,
        majorVersion: null,
        minorVersion: null,
        fromGroup: fromGroup,
        fromDestination: fromDestination,
        toGroup: toGroup,
        metadata: payload.metadata || Buffer.alloc(0)
      });
      return {
        data: payload.data,
        metadata: metadata
      };
    }, connect);
  };

  DeferredConnectingRSocket.group = function group(fromGroup, fromDestination, toGroup, connect) {
    return new DeferredConnectingRSocket(function (payload) {
      var metadata = (0, _proteusJsFrames.encodeFrame)({
        type: _proteusJsFrames.FrameTypes.GROUP,
        majorVersion: null,
        minorVersion: null,
        fromGroup: fromGroup,
        fromDestination: fromDestination,
        toGroup: toGroup,
        metadata: payload.metadata || Buffer.alloc(0)
      });
      return {
        data: payload.data,
        metadata: metadata
      };
    }, connect);
  };

  DeferredConnectingRSocket.destination = function destination(fromGroup, fromDestination, toGroup, toDestination, connect) {
    return new DeferredConnectingRSocket(function (payload) {
      var metadata = (0, _proteusJsFrames.encodeFrame)({
        type: _proteusJsFrames.FrameTypes.DESTINATION,
        majorVersion: null,
        minorVersion: null,
        fromGroup: fromGroup,
        fromDestination: fromDestination,
        toGroup: toGroup,
        toDestination: toDestination,
        metadata: payload.metadata || Buffer.alloc(0)
      });
      return {
        data: payload.data,
        metadata: metadata
      };
    }, connect);
  };

  DeferredConnectingRSocket.prototype.fireAndForget = function fireAndForget(payload) {
    var transformedPayload = this._transformer(payload);
    this._connect().subscribe({
      onComplete: function onComplete(connection) {
        return connection.fireAndForget(transformedPayload);
      }
    });
  };

  DeferredConnectingRSocket.prototype.requestResponse = function requestResponse(payload) {
    var _this = this;

    var self = this;
    return new _rsocketFlowable.Single(function (subscriber) {
      _this._connect().subscribe({
        onComplete: function onComplete(connection) {
          try {
            connection.requestResponse(self._transformer(payload)).subscribe(subscriber);
          } catch (error) {
            subscriber.onError(error);
          }
        },
        onError: function onError(error) {
          subscriber.onError(error);
        }
      });
    });
  };

  DeferredConnectingRSocket.prototype.requestStream = function requestStream(payload) {
    var _this2 = this;

    var self = this;
    return new _rsocketFlowable.Flowable(function (subscriber) {
      _this2._connect().subscribe({
        onComplete: function onComplete(connection) {
          try {
            connection.requestStream(self._transformer(payload)).subscribe(subscriber);
          } catch (error) {
            subscriber.onError(error);
          }
        },
        onError: function onError(error) {
          subscriber.onError(error);
        }
      });
    });
  };

  DeferredConnectingRSocket.prototype.requestChannel = function requestChannel(payloads) {
    var _this3 = this;

    var self = this;
    return new _rsocketFlowable.Flowable(function (subscriber) {
      _this3._connect().subscribe({
        onComplete: function onComplete(connection) {
          connection.requestChannel(payloads.map(function (payload) {
            return self._transformer(payload);
          })).subscribe(subscriber);
        },
        onError: function onError(error) {
          subscriber.onError(error);
        }
      });
    });
  };

  DeferredConnectingRSocket.prototype.metadataPush = function metadataPush(payload) {
    var _this4 = this;

    var self = this;
    return new _rsocketFlowable.Single(function (subscriber) {
      _this4._connect().subscribe({
        onComplete: function onComplete(connection) {
          try {
            connection.metadataPush(self._transformer(payload)).subscribe(subscriber);
          } catch (error) {
            subscriber.onError(error);
          }
        },
        onError: function onError(error) {
          subscriber.onError(error);
        }
      });
    });
  };

  DeferredConnectingRSocket.prototype.close = function close() {
    this._connect().subscribe({
      onComplete: function onComplete(connection) {
        connection.close();
      }
    });
  };

  DeferredConnectingRSocket.prototype.connectionStatus = function connectionStatus() {
    var _this5 = this;

    return new _rsocketFlowable.Flowable(function (subscriber) {
      _this5._connect().subscribe({
        onComplete: function onComplete(connection) {
          connection.connectionStatus().subscribe(subscriber);
        },
        onError: function onError(error) {
          subscriber.onError(error);
        }
      });
    });
  };

  return DeferredConnectingRSocket;
}();

// function establishConnection(
//   deferred: DeferredConnectingRSocket,
// ): Single<ReactiveSocket<Buffer, Buffer>> {
//   if (deferred._connected) {
//     return Single.of(deferred._connection);
//   } else if (deferred._error) {
//     return Single.error(deferred._error);
//   } else if (deferred._connecting) {
//     return deferred._connecting;
//   } else {
//     deferred._connecting = deferred._connect().flatMap(connection => {
//       deferred._connection = connection;
//       deferred._connected = true;
//       return Single.of(connection);
//     });
//     return deferred._connecting;
//   }
// }


exports.default = DeferredConnectingRSocket;